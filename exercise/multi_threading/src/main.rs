// Rust 에는 네이티브 OS 스레드로 래핑(wrapping)된 API가 있습니다.
// 커널 레벨 스레드(native threads)를 지원하는 모든 주요 플랫폼에서 동작합니다.
// MacOS, Linux, Window에 국한되지 않고요.
// 소규모 내장 운영 체제 같은 것들은 커널 레벨 스레드를 지원하지 않습니다.
// 위와같은 환경에서는 코드가 컴파일되지 않습니다.

// Process
// 모든 프로세스와 프로그램은 단일 스레드로 시작합니다.
// 보통 이 스레드를 메인 스레드라고 하죠
// 프로세스 안에서 더 많은 스레드를 실행할 수 있습니다.

// 왜 다른 프로세스나 프로그램을 실행하지 않고, 스레드를 추가로 실행할까요?
// 무엇보다 스레드가 프로세스보다 비용이 적게 들고,
// 동일한 프로세스에 있는 스레드간 메모리가 공유되기 때문입니다.
// 또한, 스레드 끼리 통신하는 게 프로세스끼리 통신하는 것 보다 좀더 쉽습니다.

// 언젠가부터 멀티 코어 시스템이 주류가 됐습니다.
// 각 논리적 코어는 한 번에 하나의 스레드를 처리할 수 있습니다.
// 단일 CPU는 하나의 CPU가 열 스레드를 동시에 처리하는 것처럼 보일 정도로
// 빠르게 스레드를 전환할 수 있습니다. (이를 멀티스레딩 이라고 합니다.)
// 하지만 실제로는 각 논리적 코어가 한 번에 하나의 스레드만 처리할 수 있습니다.
// 만약 프로그램을 두 CPU 코어의 각 스레드에 나눠 실행한다면,
// 이론적으로는 원래 실행 기간의 절반에 코어끼리 통신하는데 드는 시간을
// 더한것 만큼만 걸릴겁니다.

// Parallel Processing (병렬처리)
// 병렬 처리는 여러 CPU에서 동시에 작업을 처리하고 싶을 때 사용하는 처리 방식입니다.

use std::thread;

fn main() {
    // thread::spawn()을 호출하고
    // 네이티브 OS 스레드를 생성합니다.
    // spawn()은 인수없는 클로저를 인수로 받습니다
    // 해당 클로저는 메인 함수에서 만든 스레드에서 실행됩니다.
    // 스레드에서 실행하고 싶은 게 있다면 클로저 안에 넣으면 됩니다.
    // 자수 사용하는 방식은 클로저에서 함수만 호출하는 겁니다, 그렇게 하면 클로저 안에
    // 많은 코드를 넣을 필요가 없습니다.
    // 클로저가 무엇을 반환하든 연결(join)된 child thread 를 받을 수 있습니다.
    // spawn() 함수는 JoinHandle 을 반환합니다.
    let handle = thread::spawn(move || {
        // do stuff in a child thread
    });

    // do stuff in the main thread

    // wait until child thread has exited
    // handle 에서 join()을 호출하면 현재 스레드의 작업을 멈추고,
    // child thread 가 종료될 때까지 기다립니다.
    // 연결된 child thread에서는 Result를 반환받습니다.
    // 정상적으로 수행됐을 땐 값을 받고 문제가 생겼을 땐 에러를 받을 수 있으니까요
    handle.join().unwrap();

    // thread 에도 비용이 듭니다
    // thread 가 생성되면 스레드 전용 메모리가 할당됩니다.
    // 보통 몇 MB 정도죠
    // CPU가 스레드를 실행하다 다른 스레드로 전환할 때마다, Context Switch 비용이 발생합니다.
    // Context Switch 는 CPU가 스레드를 실행하다 다른 스레드로 전환할 때 발생하는 비용입니다.
    // 하나의 CPU 코어를 공유하는 스레드가 많아질수록, 오버헤드가 점점 증가하는 것이죠.
    // 그럼에도 스레드는 CPU와 메모리를 병렬로 사용하는 데 매우 적합합니다.
    // 동시에 여러 코어에서 실행할 수 있으니까요
    // 하지만 어떤 작업을 하면서 디스크 I/O나 네트워크 I/O 같은 작업이
    // 끝나지만을 그저 기다리기만 할 거라면, 그럴 땐 'async/await'을 쓰는게 낫습니다
    // 단일 스레드에서 한 쪽이 일방적으로 대기하는 경우에는 그게 훨씬 효율적이죠
    // 하지만 그 내용은 이 과정의 범위를 벗어난 심화 주제입니다.
    // 그럼 이제 thread 로 좀더 현실적인걸 해봅시다.
}
